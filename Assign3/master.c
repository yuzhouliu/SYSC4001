/*  SYSC 4001, Assignment 3
 *	Student: Yuzhou Liu 100853392
 */

/* =========================================================
 * This is the master process where the producer, consumer and 
 * balancing threads are created.
 * =========================================================
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#include "common_structs.h"

#define NUM_CPU 4

static int num_processes;
static cpu_run_queue cpu_run_queues[NUM_CPU];
static int consumer_finished = 0; 

void *producer_thread_function(void *arg);
void *consumer_thread_function(void *arg);

int main(int argc, char *argv[])
{

	/* User input for number of processes generated by producer */
	if (argc != 2) {
		fprintf(stderr, "Invalid number of parameters entered. Exiting\n");
		exit(EXIT_FAILURE);
	}
	num_processes = atoi(argv[1]);

 	exit(EXIT_SUCCESS);
}

void *producer_thread_function(void *arg) {
	int i;
	int curr_cpu;
	int buf_tail;
	task_struct *curr_task;
	
	printf("[Producer] Thread started\n");

	// Assigns tasks to the run queue of each CPU in round robin fashion
	// Currently putting all tasks in RQ0 and assigning basic PID
	for(i = 0; i < num_processes; i++) {
		curr_cpu = i % 4;
		buf_tail = cpu_run_queues[curr_cpu].rq0.tail;
		
		curr_task = &((cpu_run_queues[curr_cpu].rq0).tasks[buf_tail]);
		curr_task->pid = i;
		(cpu_run_queues[curr_cpu].rq0).tail++;
		
		(cpu_run_queues[curr_cpu].rq0).count++;
	}
	while(!consumer_finished) {}
	pthread_exit(NULL);
}

void *consumer_thread_function(void *arg) {
	int i;
	int cpu_num = *(int *)arg;
	task_struct *curr_task;
	
  printf("[Consumer %d] Thread started\n", cpu_num);
  for(i = 0; i < cpu_run_queues[cpu_num].rq0.count; i++) {
  	curr_task = &((cpu_run_queues[cpu_num].rq0).tasks[i]);
   	printf("[Consumer %d] Consumed: %d\n", cpu_num, curr_task->pid);
  }
  printf("[Consumer %d] Bye!\n", cpu_num);
  pthread_exit(NULL);
}

