/*  SYSC 4001, Assignment 3
 *	Student: Yuzhou Liu 100853392
 */

/* =========================================================
 * This is the master process where the producer, consumer and 
 * balancing threads are created.
 * =========================================================
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#include "common_structs.h"
#include "utility.h"

#define NUM_CPU 4

static int num_processes;
static cpu_run_queue cpu_run_queues[NUM_CPU] = {0};

void *producer_thread_function(void *arg);
void *consumer_thread_function(void *arg);

int main(int argc, char *argv[])
{
	int res;
	pthread_t producer_thread;
	void *thread_result;

	// User input for number of processes generated by producer
	if (argc != 2) {
		fprintf(stderr, "Invalid number of parameters entered. Exiting\n");
		exit(EXIT_FAILURE);
	}
	num_processes = atoi(argv[1]);

	// Create the producer thread
	res = pthread_create(&producer_thread, NULL, producer_thread_function, NULL);
	if (res != 0) {
		perror("Producer thread creation failed\n");
		exit(EXIT_FAILURE);
	}

	// Wait for producer to finish
	res = pthread_join(producer_thread, &thread_result);
	if( res != 0) {
		perror("pthread_join failed");
	}

	printf("All done\n");
 	exit(EXIT_SUCCESS);
}

void *producer_thread_function(void *arg) {
	int i;
	int curr_cpu;							// Stores the current CPU index
	int buf_tail;							// Stores the circular buffer tail
	task_struct *curr_task;

	printf("[Producer] Thread started\n");

	// Seed the random number generator
	srand(time(NULL));	

	for(i = 0; i < num_processes; i++) {
		// Assigns tasks to the run queue of each CPU in round robin fashion
		curr_cpu = i % 4;

		// Generates processes according to ratio:
		//  SCHED_FIFO 1/5 ratio
		//  SCHED_RR 1/5 ratio
		//  SCHED_NORMAL 3/5 ratio
		switch(i % 5) {
			case 0:																									// Task is SCHED_FIFO
				buf_tail = cpu_run_queues[curr_cpu].rq0.tail++;				// Update tail of circ buffer
				cpu_run_queues[curr_cpu].rq0.count++;									// Update count of circ buffer
				curr_task = &((cpu_run_queues[curr_cpu].rq0).tasks[buf_tail]);	// Current task
				curr_task->sched_type = MY_SCHED_FIFO;								// Task is SCHED_FIFO
				break;
			case 1:
				buf_tail = cpu_run_queues[curr_cpu].rq0.tail++;
				cpu_run_queues[curr_cpu].rq0.count++;
				curr_task = &((cpu_run_queues[curr_cpu].rq0).tasks[buf_tail]);
				curr_task->sched_type = MY_SCHED_RR;
				break;
			case 2:
			case 3:
			case 4:
				buf_tail = cpu_run_queues[curr_cpu].rq1.tail++;
				cpu_run_queues[curr_cpu].rq1.count++;
				curr_task = &((cpu_run_queues[curr_cpu].rq1).tasks[buf_tail]);
				curr_task->sched_type = MY_SCHED_NORMAL;
				break;
			default:
				fprintf(stderr, "[Producer] Unknown SCHED type\n");
		}
		curr_task->pid = i;																// Assign PID
 		curr_task->expected_exec_time = rand()%10 +1;			// Random number between 1 and 10
	}

	printf("[Producer] Printing list of tasks for each CPU...\n\n");
	print_task_list(cpu_run_queues, NUM_CPU);						// Print the list of tasks for each CPU
	pthread_exit(NULL);
}

/*
void *consumer_thread_function(void *arg) {
	int i;
	int cpu_num = *(int *)arg;
	task_struct *curr_task;
	
  printf("[Consumer %d] Thread started\n", cpu_num);
  for(i = 0; i < cpu_run_queues[cpu_num].rq0.count; i++) {
  	curr_task = &((cpu_run_queues[cpu_num].rq0).tasks[i]);
   	printf("[Consumer %d] Consumed: %d\n", cpu_num, curr_task->pid);
  }
  printf("[Consumer %d] Bye!\n", cpu_num);
  pthread_exit(NULL);
}
*/

